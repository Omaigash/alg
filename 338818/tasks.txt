    Удовлетворительно
1. Реализуйте класс бинарного дерева Tree с использованием класса узла Node и функцию для нахождения путей
от корня до листа, имеющих сумму значений в узлах, попадующую в диапазон [а, b], за один обход дерева.
Проверьте работу функции на различных конфигурациях деревьев. Обоснуйте и подтвердите сложность
алгоритма (график теор. и практич. времени)
Использовать list нельзя, можно from array import array
    Хорошо
1. Дан массив intervals, где intervals[i] = [start, end], объедините все перекрывающиеся интервалы и верните
массив непересекающихся интервалов, охватывающих все интервалы во входных данных. Input: intervals =
[[1,3],[8,10],[2,6],[15,18] Output: [[1,6],[8,10],[15,18]] Обоснуйте и подтвердите сложность алгоритма (график
теор. и практич. времени)
2. Проверьте, является ли заданное дерево бинарным деревом поиска с высотой больше N
